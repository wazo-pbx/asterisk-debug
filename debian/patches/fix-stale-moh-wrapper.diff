Index: asterisk-15.6.1/res/ari/resource_bridges.c
===================================================================
--- asterisk-15.6.1.orig/res/ari/resource_bridges.c
+++ asterisk-15.6.1/res/ari/resource_bridges.c
@@ -821,6 +821,7 @@ void ast_ari_bridges_start_moh(struct as
 	}
 
 	ast_moh_start(moh_channel, moh_class, NULL);
+	ast_channel_cleanup(moh_channel);
 
 	ast_ari_response_no_content(response);
 
Index: asterisk-15.6.1/res/res_stasis.c
===================================================================
--- asterisk-15.6.1.orig/res/res_stasis.c
+++ asterisk-15.6.1/res/res_stasis.c
@@ -472,29 +472,6 @@ static int bridges_channel_sort_fn(const
 	return cmp;
 }
 
-/*! Removes the bridge to music on hold channel link */
-static void remove_bridge_moh(char *bridge_id)
-{
-	ao2_find(app_bridges_moh, bridge_id, OBJ_SEARCH_KEY | OBJ_UNLINK | OBJ_NODATA);
-	ast_free(bridge_id);
-}
-
-/*! After bridge failure callback for moh channels */
-static void moh_after_bridge_cb_failed(enum ast_bridge_after_cb_reason reason, void *data)
-{
-	char *bridge_id = data;
-
-	remove_bridge_moh(bridge_id);
-}
-
-/*! After bridge callback for moh channels */
-static void moh_after_bridge_cb(struct ast_channel *chan, void *data)
-{
-	char *bridge_id = data;
-
-	remove_bridge_moh(bridge_id);
-}
-
 /*! Request a bridge MOH channel */
 static struct ast_channel *prepare_bridge_moh_channel(void)
 {
@@ -517,11 +494,21 @@ static struct ast_channel *prepare_bridg
 /*! Provides the moh channel with a thread so it can actually play its music */
 static void *moh_channel_thread(void *data)
 {
-	struct ast_channel *moh_channel = data;
+	struct stasis_app_bridge_channel_wrapper *moh_wrapper = data;
+	struct ast_channel *moh_channel = ast_channel_get_by_name(moh_wrapper->channel_id);
+
+	if (!moh_channel) {
+		ao2_unlink(app_bridges_moh, moh_wrapper);
+		ao2_ref(moh_wrapper, -1);
+		return NULL;
+	}
 
 	while (!ast_safe_sleep(moh_channel, 1000)) {
 	}
 
+	ao2_unlink(app_bridges_moh, moh_wrapper);
+	ao2_ref(moh_wrapper, -1);
+
 	ast_moh_stop(moh_channel);
 	ast_hangup(moh_channel);
 
@@ -558,14 +545,6 @@ static struct ast_channel *bridge_moh_cr
 		return NULL;
 	}
 
-	/* The after bridge callback assumes responsibility of the bridge_id. */
-	if (ast_bridge_set_after_callback(chan,
-		moh_after_bridge_cb, moh_after_bridge_cb_failed, bridge_id)) {
-		ast_hangup(chan);
-		return NULL;
-	}
-	bridge_id = NULL;
-
 	if (ast_unreal_channel_push_to_bridge(chan, bridge,
 		AST_BRIDGE_CHANNEL_FLAG_IMMOVABLE | AST_BRIDGE_CHANNEL_FLAG_LONELY)) {
 		ast_hangup(chan);
@@ -579,20 +558,22 @@ static struct ast_channel *bridge_moh_cr
 		return NULL;
 	}
 
-	if (ast_string_field_init(new_wrapper, 32)) {
+	if (ast_string_field_init(new_wrapper, AST_UUID_STR_LEN + AST_CHANNEL_NAME)
+		|| ast_string_field_set(new_wrapper, bridge_id, bridge->uniqueid)
+		|| ast_string_field_set(new_wrapper, channel_id, ast_channel_uniqueid(chan))) {
 		ast_hangup(chan);
 		return NULL;
 	}
-	ast_string_field_set(new_wrapper, bridge_id, bridge->uniqueid);
-	ast_string_field_set(new_wrapper, channel_id, ast_channel_uniqueid(chan));
 
 	if (!ao2_link_flags(app_bridges_moh, new_wrapper, OBJ_NOLOCK)) {
 		ast_hangup(chan);
 		return NULL;
 	}
 
-	if (ast_pthread_create_detached(&threadid, NULL, moh_channel_thread, chan)) {
+	ao2_ref(new_wrapper, +1);
+	if (ast_pthread_create_detached(&threadid, NULL, moh_channel_thread, new_wrapper)) {
 		ast_log(LOG_ERROR, "Failed to create channel thread. Abandoning MOH channel creation.\n");
+		ao2_ref(new_wrapper, -1);
 		ao2_unlink_flags(app_bridges_moh, new_wrapper, OBJ_NOLOCK);
 		ast_hangup(chan);
 		return NULL;
