Index: asterisk-16.7.0/res/res_stasis.c
===================================================================
--- asterisk-16.7.0.orig/res/res_stasis.c
+++ asterisk-16.7.0/res/res_stasis.c
@@ -1704,7 +1704,7 @@ struct ao2_container *stasis_app_get_all
 
 static int __stasis_app_register(const char *app_name, stasis_app_cb handler, void *data, int all_events)
 {
-	RAII_VAR(struct stasis_app *, app, NULL, ao2_cleanup);
+	struct stasis_app *app;
 
 	if (!apps_registry) {
 		return -1;
@@ -1713,43 +1713,36 @@ static int __stasis_app_register(const c
 	ao2_lock(apps_registry);
 	app = ao2_find(apps_registry, app_name, OBJ_SEARCH_KEY | OBJ_NOLOCK);
 	if (app) {
-		/*
-		 * We need to unlock the apps_registry before calling app_update to
-		 * prevent the possibility of a deadlock with the session.  We'll still
-		 * run the lazy cleanup first though.
-		 */
-		cleanup();
-		ao2_unlock(apps_registry);
 		app_update(app, handler, data);
-		return 0;
-	}
+	} else {
+		app = app_create(app_name, handler, data, all_events ? STASIS_APP_SUBSCRIBE_ALL : STASIS_APP_SUBSCRIBE_MANUAL);
+		if (!app) {
+			ao2_unlock(apps_registry);
+			return -1;
+		}
 
-	app = app_create(app_name, handler, data, all_events ? STASIS_APP_SUBSCRIBE_ALL : STASIS_APP_SUBSCRIBE_MANUAL);
-	if (!app) {
-		ao2_unlock(apps_registry);
-		return -1;
-	}
+		if (all_events) {
+			struct stasis_app_event_source *source;
 
-	if (all_events) {
-		struct stasis_app_event_source *source;
+			AST_RWLIST_RDLOCK(&event_sources);
+			AST_LIST_TRAVERSE(&event_sources, source, next) {
+				if (!source->subscribe) {
+					continue;
+				}
 
-		AST_RWLIST_RDLOCK(&event_sources);
-		AST_LIST_TRAVERSE(&event_sources, source, next) {
-			if (!source->subscribe) {
-				continue;
+				source->subscribe(app, NULL);
 			}
-
-			source->subscribe(app, NULL);
+			AST_RWLIST_UNLOCK(&event_sources);
 		}
-		AST_RWLIST_UNLOCK(&event_sources);
+		ao2_link_flags(apps_registry, app, OBJ_NOLOCK);
 	}
-	ao2_link_flags(apps_registry, app, OBJ_NOLOCK);
 
 	/* We lazily clean up the apps_registry, because it's good enough to
 	 * prevent memory leaks, and we're lazy.
 	 */
 	cleanup();
 	ao2_unlock(apps_registry);
+	ao2_ref(app, -1);
 	return 0;
 }
 
Index: asterisk-16.7.0/res/ari/resource_events.c
===================================================================
--- asterisk-16.7.0.orig/res/ari/resource_events.c
+++ asterisk-16.7.0/res/ari/resource_events.c
@@ -81,16 +81,9 @@ static void stasis_app_message_handler(
 {
 	struct event_session *session = data;
 	const char *msg_type, *msg_application;
-	int app_debug_enabled;
 
 	ast_assert(session != NULL);
 
-	/*
-	 * We need to get the debug flag before lockinf session
-	 * to help prevent a deadlock with the apps_registry container.
-	 */
-	app_debug_enabled = stasis_app_get_debug_by_name(app_name);
-
 	ao2_lock(session);
 
 	msg_type = S_OR(ast_json_string_get(ast_json_object_get(message, "type")), "");
@@ -122,7 +115,7 @@ static void stasis_app_message_handler(
 				msg_type,
 				msg_application);
 	} else if (stasis_app_event_allowed(app_name, message)) {
-		if (app_debug_enabled) {
+		if (stasis_app_get_debug_by_name(app_name)) {
 			char *str = ast_json_dump_string_format(message, ast_ari_json_format());
 
 			ast_verbose("<--- Sending ARI event to %s --->\n%s\n",
